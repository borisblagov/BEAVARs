var documenterSearchIndex = {"docs":
[{"location":"Chan2020_csv/#Chan2020_csv","page":"Chan2020_csv","title":"Chan2020_csv","text":"","category":"section"},{"location":"Banbura2010/#Banbura2010","page":"Banbura2010","title":"Banbura2010","text":"","category":"section"},{"location":"Banbura2010/#Minnesota-prior-via-dummy-observations","page":"Banbura2010","title":"Minnesota prior via dummy observations","text":"","category":"section"},{"location":"Banbura2010/","page":"Banbura2010","title":"Banbura2010","text":"makeDummiesMinn!(sigma::Vector{Float64},delta::Vector{Float64},lambda,n::Integer,p::Integer,epsi,Y_d1,X_d1)","category":"page"},{"location":"Banbura2010/#BEAVARs.makeDummiesMinn!-Tuple{Vector{Float64}, Vector{Float64}, Any, Integer, Integer, Any, Any, Any}","page":"Banbura2010","title":"BEAVARs.makeDummiesMinn!","text":"makeDummiesMinn!(sigma::Vector{Float64},delta,lambda,n::Integer,p::Integer,Y_d1))\n\nFills a matrix Y_d and X_d following eq. (5) in Banbura, Giannone, Reichling (2010), JAE, Large Bayesian Autoregressions. \n\nY_d =   beginbmatrix\n         diag(σ_1*δ_1 dots σ_N*δ_n)λ\r\n         mathbf0_n*(p-1) times n\r\n         diag(σ_1 dots σ_n)\r\n         mathbf0_1n times n\n         endbmatrix\n\nX_d = beginbmatrix\n        diag(1dotsp) otimes diag(σ_1 dots σ_n) λ quad mathbf0_n*p1\r\n        mathbf0_nn*p+1\r\n        mathbf0_1n*p  ε\r\n        endbmatrix\n\nInstad of creating the matrix every time, the function uses mutation on matrices called Y_d1 and X_d1.\n\nFor Y_d1 it is the the diagonal of the first (1:n,1:n) block and in the diagonal of the third block n+n*(p-1)+1:n+n*(p-1)+n\n\nFor X_d1 it is the diagonal of the first (n * p x n * p), esesntially X_d1 is populated along its diagonal and only the constant is added at the end\n\nfunction makeDummiesMinn!(sigma::Vector{Float64},delta::Vector{Float64},lambda,n::Integer,p::Integer,epsi,Y_d1,X_d1)\n    CI1_Yd1 = CartesianIndex.(1:n,1:n)  # These are the diagonal indices for the top block \n    CI2_Yd1 = CartesianIndex.(n+n*(p-1)+1:n+n*(p-1)+n,1:n)  # These are the diagonal indices for the block in the middle\n    CI_Xd1 = CartesianIndex.(1:n*p,1:n*p)\n    Y_d1[CI1_Yd1] = sigma.*delta./lambda;\n    Y_d1[CI2_Yd1] = sigma;\n    X_d1[end,end] = epsi;\n    X_d1[CI_Xd1]  = repeat(sigma./lambda,p).*repeat(1:p,inner=n)\n    return Y_d1, X_d1;\nend\n\n\n\n\n\n","category":"method"},{"location":"#BEAVARs.jl-Documentation","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"","category":"section"},{"location":"","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"BEAVARs.jl: Bayesian Econometric Analysis using Vector Autoregressive models","category":"page"},{"location":"","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"This is a personal package implementing various Bayesian VARs for economic analysis and forecasting. ","category":"page"},{"location":"","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"Currently implemented VARs:","category":"page"},{"location":"","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"Banbura2010: BVAR with dummy observations as in Banbura, M., Giannone, D., and Reichlin, L. (2010), Large Bayesian vecotr auto regressions, Journal of Applied Econometrics, Vol 25(1), doi.org/10.1002/jae.1137.\nChan2020_Minn: BVAR with classical  Minnesota prior (homoscedastic fixed variance-covariance matrix) as in Chan, J.C.C. (2020), Large Bayesian Vecotrautoregressions, P. Fuleky (Eds), Macroeconomic Forecasting in the Era of Big Data, 95-125, Springer, Cham, https://doi.org/10.1007/978-3-030-31150-6, see also joshuachan.org and his pdf.\nChan2020_csv: BVAR with Minnesota prior and common stochastic volatility (csv) as in Chan, J.C.C. (2020), Large Bayesian Vecotrautoregressions, P. Fuleky (Eds), Macroeconomic Forecasting in the Era of Big Data, 95-125, Springer, Cham, https://doi.org/10.1007/978-3-030-31150-6, see also joshuachan.org and his pdf.","category":"page"},{"location":"","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"Each model is contained in a separate function. See the documetnation for details. Note that notation follows the original reference. Consequently variable and parameter names are different across functions (e.g. lambda_1 in one paper can be c_1 in another). ","category":"page"},{"location":"","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"Some codes have been translated from Matlab, so there is a lot of room for optimization. ","category":"page"},{"location":"#Documentation-for-the-models","page":"BEAVARs.jl Documentation","title":"Documentation for the models","text":"","category":"section"},{"location":"","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"Pages = [\"Banbura2010.md\", \"Chan2020_Minn.md\", \"Chan2020_csv.md\"]\nDepth = 1","category":"page"},{"location":"#References","page":"BEAVARs.jl Documentation","title":"References","text":"","category":"section"},{"location":"","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"Banbura, Marta, Giannone, Domenico and Reichlin, Lucrezia, (2010), Large Bayesian vector auto regressions, Journal of Applied Econometrics, 25, issue 1, p. 71-92. https://doi.org/10.1002/jae.1137. ","category":"page"},{"location":"","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"Chan, J.C.C. (2020), Large Bayesian Vecotrautoregressions, P. Fuleky (Eds), Macroeconomic Forecasting in the Era of Big Data, 95-125, Springer, Cham, https://doi.org/10.1007/978-3-030-31150-6","category":"page"},{"location":"#Notes-on-the-name","page":"BEAVARs.jl Documentation","title":"Notes on the name","text":"","category":"section"},{"location":"","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"The name BEAVARs is an obvious play of words with a misspelled version of my favourite animal.","category":"page"},{"location":"","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"It is also a nod to the BEAR Toolbox - Bayesian  Estimation, Analysis and Regression, which is a powerful Matlab toolbox for estimating various VAR, BVAR, and Panel VAR models. While this is not an attempt to reach the size and scope of BEAR in the Julia ecosystem, there are some clear similarities in the idea of easy estimation of various models.","category":"page"},{"location":"","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"It does not conform to the widely accepted convention of naming Julia packages (Capital letter followed by all lowercase) but it doesn't break any rules either. It isn't the only package with more than one capita letter, e.g. FFT, CUDA, CSV etc. Also, because it's misspelled on purpose, the name Beaver.jl remains open, and if someone does that one could still distinguish the packages BEAVARs.jl and Beavers.jl easily.","category":"page"},{"location":"#Acknowledgmenets","page":"BEAVARs.jl Documentation","title":"Acknowledgmenets","text":"","category":"section"},{"location":"","page":"BEAVARs.jl Documentation","title":"BEAVARs.jl Documentation","text":"I would like to thank Guillaume Dalle, who, even though it is not associated with this package went out of his way to help me get my first steps in Github and Julia optimization. Also, many users in the Julia discourse helped me when I was struggling - this community is great.","category":"page"},{"location":"init_functions/#Additional-functions","page":"Additional functions","title":"Additional functions","text":"","category":"section"},{"location":"init_functions/","page":"Additional functions","title":"Additional functions","text":"makeSetup(YY::Array{Float64},model=model_str; p::Int,nburn::Int,nsave::Int,n_irf::Int,n_fcst::Int)","category":"page"},{"location":"init_functions/#BEAVARs.makeSetup","page":"Additional functions","title":"BEAVARs.makeSetup","text":"makeSetup(YY::Array{Float64},model=modelstr; p::Int,nburn::Int,nsave::Int,nirf::Int,n_fcst::Int)\n\nPopulates the constructor VARSetup with default and/or custom values.\n\nMandatory arguments (write directly the argument):\n\nYY:     your data in a matrix form\nmodel:  the model string you want to use. Currently supported are \"Banbura2010\", \"Chan2020_LBA_Minn\", \"Chan2020_LBA_csv\".\n\nKeyword arguments (e.g. p = 4). They don't have to be specified.\n\np:      number of lags, default is 4\nnburn:  number of burn-in draws that will be discarded, default is 2000\nnsave:  number of retained draws (total is then nburn + nsave), default is 1000\nn_irf:  horizon of impulse responses, default is 16\nn_fcst: horizon of forecasting periods, default is 8\n\nOutputs\n\nVARSetup: the setup structure for the BEAVARs\nHyperSetup: the setup structure for hyperparameters with default values. If you want to modify these, disregard the output and do it outside\n\nExamples\n\njulia> YY = randn(10,3); makeSetup(YY::Array{Float64},\"Banbura2010\")\n(BEAVARs.VARSetup\n  n: Int64 3\n  p: Int64 4\n  nsave: Int64 1000\n  nburn: Int64 1000\n  n_irf: Int64 16\n  n_fcst: Int64 8\n  const_loc: Int64 0\n, hypBanbura2010\n  lambda: Float64 0.1\n  epsi: Float64 0.001\n)\n\njulia> YY = randn(10,5); makeSetup(YY::Array{Float64},\"Banbura2010\",p=1,nburn=500,nsave=100,n_irf=4,n_fcst=12)\n(BEAVARs.VARSetup\n  n: Int64 5\n  p: Int64 1\n  nsave: Int64 100\n  nburn: Int64 500\n  n_irf: Int64 4\n  n_fcst: Int64 12\n  const_loc: Int64 0\n, hypBanbura2010\n  lambda: Float64 0.1\n  epsi: Float64 0.001\n)\n\n\n\n\n\n","category":"function"},{"location":"init_functions/","page":"Additional functions","title":"Additional functions","text":"ols(Y,X)","category":"page"},{"location":"init_functions/#BEAVARs.ols-Tuple{Any, Any}","page":"Additional functions","title":"BEAVARs.ols","text":"ols(Y,X)\n\nPerforms standard linear regression on two matrices Y and X, returning β as a vector, the vector of residuals ε and the variance σ_sq\n\n\n\n\n\n","category":"method"},{"location":"init_functions/","page":"Additional functions","title":"Additional functions","text":"mlag(Yfull::Matrix{Float64},p::Integer)","category":"page"},{"location":"init_functions/#BEAVARs.mlag-Tuple{Matrix{Float64}, Integer}","page":"Additional functions","title":"BEAVARs.mlag","text":"mlag(Yfull::Matrix{Float64},p::Integer)\nCreates lags of a matrix for a VAR representation with a constant on the right\n    Yfull: a matrix of dimensions T+p x N returns a matrix Y with dimensions TxN and X with dimenions Tx(N*p+1)\n\n\n\n\n\n","category":"method"},{"location":"init_functions/","page":"Additional functions","title":"Additional functions","text":"mlag_r(Yfull::Matrix{Float64},p::Integer)","category":"page"},{"location":"init_functions/#BEAVARs.mlag_r-Tuple{Matrix{Float64}, Integer}","page":"Additional functions","title":"BEAVARs.mlag_r","text":"mlag_r(Yfull::Matrix{Float64},p::Integer)\nCreates lags of a matrix for a VAR representation with a constant on the left\n    Yfull: a matrix of dimensions T+p x N returns a matrix Y with dimensions TxN and X with dimenions Tx(N*p+1)\n\n\n\n\n\n","category":"method"},{"location":"init_functions/","page":"Additional functions","title":"Additional functions","text":"trainPriors(Z0::Matrix{Float64},p::Int64)","category":"page"},{"location":"init_functions/#BEAVARs.trainPriors-Tuple{Matrix{Float64}, Int64}","page":"Additional functions","title":"BEAVARs.trainPriors","text":"trainPriors(Z0::Matrix{Float64},p::Int64)\n\nIndependent AR(p) regressions with constant to estimate prior values for further Bayesian estimation\n\nFor a training sample Z0 with n variables and p lags the function will do column-wise n linear regressions of order p and return a matrix \n\ndeltaP has the constant on the bottom and the lags (1) to (p) in rows [1:end-1,:]\n\n\n\n\n\n","category":"method"},{"location":"init_functions/","page":"Additional functions","title":"Additional functions","text":"percentile_mat(A, p; dims)","category":"page"},{"location":"Chan2020_Minn/#Chan2020_Minn","page":"Chan2020_Minn","title":"Chan2020_Minn","text":"","category":"section"},{"location":"Chan2020_Minn/","page":"Chan2020_Minn","title":"Chan2020_Minn","text":"Chan2020_LBA_Minn(YY,VARSetup,HyperSetup)","category":"page"},{"location":"Chan2020_Minn/#BEAVARs.Chan2020_LBA_Minn-Tuple{Any, Any, Any}","page":"Chan2020_Minn","title":"BEAVARs.Chan2020_LBA_Minn","text":"Chan2020LBAMinn(YY,VARSetup,HyperSetup)\n\nImplements the classic homoscedastic Minnesota prior with a SUR form following Chan (2020)\n\n\n\n\n\n","category":"method"}]
}
